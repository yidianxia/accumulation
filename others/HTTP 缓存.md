> 重用已获取的资源能够有效的提升网站与应用的性能。 Web 缓存能够减少延迟与网络阻塞， 进而减少某个资源所用的时间。 借助HTTP 缓存，Web站点变得更具有响应性。
>
> 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。

**前端与后端都可以设置 前端设置在meta，后端设置在reponse header。**

#### **强缓存**

当缓存数据库中已有所请求的数据时， 客户端直接从缓存数据库中获得数据。当缓存数据库中没有所请求的数据时，客户端才会从服务端获取数据。

对于强制缓存，服务器响应的 header 中会用两个字段来表明——Expires 和 Cache-Control。

- **expires**

`expires` 是 `HTTP1.0` 中定义的缓存字段。当我们请求一个资源，服务器返回时，可以在 `Response Headers` 中增加 `expires` 字段表示资源的过期时间。

```http
expires: Thu, 03 Jan 2019 11:43:04 GMT
```

它是一个**时间戳**（准确点应该叫格林尼治时间），当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源。

但是，有个大问题，发送请求时是使用的**客户端时间**去对比。一是客户端和服务端时间可能快慢不一致，另一方面是客户端的时间是可以自行修改的（比如浏览器是跟随系统时间的，修改系统时间会影响到），所以不一定满足预期

- **cache-control**

由于上述可能存在的问题，`HTTP1.1` 新增了 `cache-control` 字段来解决该问题，所以当 `cache-control` 和 `expires` 都存在时，`cache-control `  **优先级更高**。

该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它**不依赖客户端时间**。`cache-control` 主要有 `max-age` 和 `s-maxage`、`public` 和 `private`、`no-cache` 和 `no-store` 等值。

| 值               | 描述                                                         |
| ---------------- | :----------------------------------------------------------- |
| no-store         | 表示禁止进行缓存！ 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。直接与服务器交互，会直接忽略 `max-age` |
| no-cache         | 表示每次有请求发出时，缓存会将此请求发送到服务器（携带与本地缓存相关的验证字段），服务器会验证请求中所描述的缓存是否过期（即协商缓存）。如果没有过期（实际返回的就是 304），则缓存才使用本地缓存副本。直接与服务器交互，会直接忽略 `max-age` |
| public           | 表示该响应可以被任何中间人（比如中间代理，CDN）缓存。        |
| private          | 表示该响应是专用于某个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。 |
| max-age          | 表示自愿能够被缓存的最大时间，但相对于Expires 而言，max-age 是距离请求发起的时间的秒数。可以通过设置 `max-age` 为 0 表示立马过期来向服务器请求资源。 |
| s-maxage         | `s-maxage` 的优先级高于 `max-age`。在代理服务器中，只有 `s-maxage` 起作用。当设置了`s-maxage` 的时候表示允许代理服务器缓存，相当于 `public` |
| must-revalidates | 缓存在考虑使用一个陈旧的旧资源时，必须先验证它的状态，已过期的缓存将不被使用。 |

**Pragma 头**

[`Pragma`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma) 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。

#### **协商缓存**

上面的 `expires` 和 `cache-control` 都会**访问本地缓存直接验证**看是否过期，如果没过期直接使用本地缓存，并返回 200。但如果设置了 `no-cache` 和 `no-store` 则本地缓存会被忽略，会去**请求服务器验证**资源是否更新，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。协商缓存主要包括 `last-modified` 和 `etag`。

协商缓存的 `Etag` 和 `Last-Modified` 同时存在时，会先对 `Etag` 进行比对，随后才是 `Last-Modified`。 即：`ETag` 优先级 > `Last-Modified` 优先级。

**两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不再进行缓存协商。**

**Last-Modified**

`last-modified` 记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个 `last-modified` 字段，如下：

```http
last-modified: Thu, 20 Dec 2018 11:36:00 GMT
```

当再次请求该资源时，请求头中会带有 `if-modified-since` 字段，值是之前返回的 `last-modified` 的值，如：`if-modified-since:Thu, 20 Dec 2018 11:36:00 GMT`。服务端会对比该字段和资源的最后修改时间。

1. 如果真的被修改：直接返回修改后的资源，服务器返回：200 OK  并修改`last-modified` 为新的值。
2. 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified

但 `last-modified` 有以下两个缺点：

- 只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应，而这正是缓存本来的作用即避免没必要的请求。
- 时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。

#### Etag

为了解决 `last-modified` 上述问题，有了 `etag`。 `etag` 会基于资源的内容编码生成一串唯一的标识字符串，只要内容不同，就会生成不同的 `etag`。 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定），请求资源后的响应返回会增加一个 `etag` 字段，如下：

```http
etag: "FllOiaIvA1f-ftHGziLgMIMVkVw_"
```

当再次请求该资源时，请求头会带有 `if-no-match` 字段，值是之前返回的 `etag` 值，如：`if-no-match:"FllOiaIvA1f-ftHGziLgMIMVkVw_"`。服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比。

1. 不同，说明资源被改动过，则响应整个资源内容，返回状态码 200 并修改返回的 `etag` 字段为新的值。
2. 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码 304.

但是实际应用中由于 etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以要如何使用 `last-modified` 和 `etag` 还需要根据具体需求进行权衡。

---

#### 访问刷新分析

我们将访问和刷新分为以下三种情况：

- 标签进入、输入 url 回车进入
- 按刷新按钮、F5 刷新、网页右键“重新加载”
- ctrl + F5 强制刷新

假设当前有这么一个 index 页面，返回的响应信息如下：

```
cache-control: max-age=72000
expires: Tue, 20 Nov 2018 20:41:14 GMT
last-modified: Tue, 20 Nov 2018 00:41:14 GMT
```

##### 1、标签进入、输入url回车进入

这种情况下会根据实际设计的缓存策略去判断。

1. 由于该例没有设置 `no-cache` 和 `no-store`，所以默认先走强缓存路线。根据 `cache-control` （`expires` 优先级低）判断缓存是否过期，若没有过期则此时返回 `200(from cache)`。
2. 若本地缓存已经过期再走协商缓存路线，根据之前的 `last-modified` 值去与服务器比对，若这个时间之后没有改过则去读取本地缓存，返回 `304(not modified)`。
3. 否则返回新的资源，状态码 `200(ok)`，并更新返回响应的 `last-modified` 值。

##### 2、按刷新按钮、F5 刷新、网页右键“重新加载”

这种情况下，实际是浏览器将 `cache-control` 的 `max-age` 直接设置成了 0，让缓存立即过期，直接走协商缓存路线。发送的请求头如下：

```
cache-control: max-age=0
if-modified-since: Tue, 20 Nov 2018 00:41:14 GMT
```

##### 3、ctrl + F5 强制刷新

强制刷新的情况下，浏览器会强行设置 `no-cache`，强制获取最新的资源，就连 `if-modified-since` 等其他缓存协议字段都会被吃掉。此时发送的请求头如下：

```
cache-control: no-cache
pragma: no-cache
```

---

**加速资源**

更多地利用缓存资源，可以提高网站的性能和响应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。

web开发者发明了一种被 Steve Souders 称之为 `revving` 的技术。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。

这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。

